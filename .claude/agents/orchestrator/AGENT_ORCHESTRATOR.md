---
name: agent-orchestrator
description: "Intelligent agent selection and workflow coordination system for optimal task-agent matching"
autogenerated: true
auto_execute: true
auto_confirm: true
strict: true
mcp:
  capabilities:
    - read_files
    - write_files
    - list_directory
    - monitor_changes
  watch_paths:
    - "@./.claude/agents/registry"
    - "@./CLAUDE.md"
    - "@./docs"
---

# Agent Orchestrator - Intelligent Task-Agent Matching System

## Overview

The Agent Orchestrator is the core intelligence engine that automatically selects and coordinates the optimal agents for any given task. It leverages the AI Agent Registry to analyze task requirements, match capabilities, and orchestrate complex multi-agent workflows with precision and efficiency.

## System Architecture

    mermaid

graph TB
subgraph "Input Layer"
UserRequest[User Task Request]
TaskScanner[Task Scanner]
end

    subgraph "Analysis Engine"
        ContextAnalyzer[Context Analyzer]
        ComplexityEvaluator[Complexity Evaluator]
        DomainMapper[Domain Mapper]
    end

    subgraph "Matching Engine"
        CapabilityMatcher[Capability Matcher]
        PerformanceScorer[Performance Scorer]
        ResourceBalancer[Resource Balancer]
        CostOptimizer[Cost Optimizer]
    end

    subgraph "Decision Engine"
        SelectionLogic[Selection Logic]
        WorkflowPlanner[Workflow Planner]
        QualityController[Quality Controller]
    end

    subgraph "Execution Layer"
        AgentExecutor[Agent Executor]
        WorkflowMonitor[Workflow Monitor]
        QualityValidator[Quality Validator]
    end

    subgraph "Learning System"
        PerformanceTracker[Performance Tracker]
        PatternLearner[Pattern Learner]
        RegistryUpdater[Registry Updater]
    end

    UserRequest --> TaskScanner
    TaskScanner --> ContextAnalyzer
    ContextAnalyzer --> ComplexityEvaluator
    ComplexityEvaluator --> DomainMapper
    DomainMapper --> CapabilityMatcher
    CapabilityMatcher --> PerformanceScorer
    PerformanceScorer --> ResourceBalancer
    ResourceBalancer --> CostOptimizer
    CostOptimizer --> SelectionLogic
    SelectionLogic --> WorkflowPlanner
    WorkflowPlanner --> QualityController
    QualityController --> AgentExecutor
    AgentExecutor --> WorkflowMonitor
    WorkflowMonitor --> QualityValidator
    QualityValidator --> PerformanceTracker
    PerformanceTracker --> PatternLearner
    PatternLearner --> RegistryUpdater
    RegistryUpdater --> CapabilityMatcher

## Core Components

### 1. Task Analysis Engine

    typescript

interface TaskAnalysis {
// Basic Information
id: string;
description: string;
timestamp: Date;

// Complexity Analysis
complexity: {
score: number; // 1-10
factors: string[];
estimated_duration: number; // minutes
};

// Domain Requirements
domains: {
primary: string[];
secondary: string[];
cross_cutting: string[];
};

// Capability Requirements
capabilities: {
required: string[];
preferred: string[];
optional: string[];
};

// Integration Requirements
integration: {
dependencies: string[];
apis: string[];
data_sources: string[];
};

// Quality Requirements
quality: {
performance: PerformanceSpec;
security: SecurityLevel;
compliance: ComplianceSpec;
accessibility: AccessibilityLevel;
};

// Constraints
constraints: {
timeline: TimelineConstraint;
budget: BudgetConstraint;
resources: ResourceConstraint;
};
}

class TaskAnalyzer {
analyzeTask(taskDescription: string, context: ProjectContext): TaskAnalysis {
const analysis: TaskAnalysis = {
id: this.generateTaskId(),
description: taskDescription,
timestamp: new Date(),
complexity: this.evaluateComplexity(taskDescription),
domains: this.mapDomains(taskDescription),
capabilities: this.extractCapabilities(taskDescription),
integration: this.identifyIntegrationNeeds(taskDescription),
quality: this.determineQualityRequirements(taskDescription, context),
constraints: this.identifyConstraints(taskDescription, context)
};

    return analysis;

}

private evaluateComplexity(description: string): ComplexityScore {
const factors = this.extractComplexityFactors(description);
const score = this.calculateComplexityScore(factors);
const duration = this.estimateDuration(score, factors);

    return { score, factors, estimated_duration: duration };

}
}

### 2. Agent Matching Engine

    typescript

interface AgentMatch {
agent: AgentProfile;
matchScore: number;
capabilityMatch: number;
performanceScore: number;
availabilityScore: number;
costScore: number;
reasoning: string[];
confidence: number;
}

class AgentMatcher {
async findOptimalAgents(task: TaskAnalysis): Promise<AgentMatch[]> {
// 1. Filter by capability match
const capableAgents = this.registry.filterByCapabilities(task.capabilities.required);

    // 2. Score each agent
    const matches = await Promise.all(
      capableAgents.map(agent => this.scoreAgentMatch(agent, task))
    );

    // 3. Sort by match score
    const sortedMatches = matches
      .filter(match => match.matchScore > 0.7)
      .sort((a, b) => b.matchScore - a.matchScore);

    return sortedMatches;

}

private async scoreAgentMatch(agent: AgentProfile, task: TaskAnalysis): Promise<AgentMatch> {
const capabilityMatch = this.calculateCapabilityMatch(agent, task);
const performanceScore = this.calculatePerformanceScore(agent, task);
const availabilityScore = await this.calculateAvailabilityScore(agent);
const costScore = this.calculateCostScore(agent, task);

    const weights = {
      capability: 0.4,
      performance: 0.25,
      availability: 0.2,
      cost: 0.15
    };

    const matchScore =
      capabilityMatch * weights.capability +
      performanceScore * weights.performance +
      availabilityScore * weights.availability +
      costScore * weights.cost;

    const reasoning = this.generateReasoning(agent, task, {
      capabilityMatch,
      performanceScore,
      availabilityScore,
      costScore
    });

    const confidence = this.calculateConfidence(matchScore, agent.success_rate);

    return {
      agent,
      matchScore,
      capabilityMatch,
      performanceScore,
      availabilityScore,
      costScore,
      reasoning,
      confidence
    };

}
}

### 3. Workflow Planner

    typescript

interface WorkflowPlan {
id: string;
task: TaskAnalysis;
agents: AgentAssignment[];
coordination_pattern: CoordinationPattern;
sequence: WorkflowStep[];
quality_gates: QualityGate[];
estimated_duration: number;
success_probability: number;
fallback_strategies: FallbackStrategy[];
}

interface AgentAssignment {
agent: AgentProfile;
role: string;
responsibilities: string[];
dependencies: string[];
estimated_duration: number;
}

class WorkflowPlanner {
planWorkflow(task: TaskAnalysis, matches: AgentMatch[]): WorkflowPlan {
const pattern = this.determineCoordinationPattern(task, matches);
const assignments = this.createAgentAssignments(matches, pattern);
const sequence = this.createWorkflowSequence(assignments, pattern);
const qualityGates = this.setupQualityGates(task, sequence);

    return {
      id: this.generateWorkflowId(),
      task,
      agents: assignments,
      coordination_pattern: pattern,
      sequence,
      quality_gates: qualityGates,
      estimated_duration: this.estimateTotalDuration(sequence),
      success_probability: this.calculateSuccessProbability(assignments, qualityGates),
      fallback_strategies: this.createFallbackStrategies(assignments)
    };

}

private determineCoordinationPattern(task: TaskAnalysis, matches: AgentMatch[]): CoordinationPattern {
if (task.complexity.score >= 8 && matches.length > 2) {
return 'hierarchical';
} else if (task.domains.primary.length > 1 && matches.length > 1) {
return 'parallel';
} else {
return 'sequential';
}
}
}

### 4. Quality Controller

    typescript

interface QualityGate {
id: string;
name: string;
type: 'pre_execution' | 'post_execution' | 'intermediate';
criteria: QualityCriteria[];
actions: QualityAction[];
required: boolean;
}

interface QualityCriteria {
metric: string;
threshold: number;
operator: 'gte' | 'lte' | 'eq' | 'gt' | 'lt';
weight: number;
}

class QualityController {
setupQualityGates(task: TaskAnalysis, sequence: WorkflowStep[]): QualityGate[] {
const gates: QualityGate[] = [];

    // Pre-execution gates
    gates.push(this.createCapabilityValidationGate(task));
    gates.push(this.createResourceAvailabilityGate());

    // Intermediate gates (for complex workflows)
    if (sequence.length > 2) {
      gates.push(this.createProgressValidationGate());
    }

    // Post-execution gates
    gates.push(this.createOutputQualityGate(task));
    gates.push(this.createPerformanceValidationGate(task));
    gates.push(this.createSecurityValidationGate(task));

    return gates;

}

private createOutputQualityGate(task: TaskAnalysis): QualityGate {
return {
id: 'output_quality',
name: 'Output Quality Validation',
type: 'post_execution',
criteria: [
{
metric: 'completeness',
threshold: 0.95,
operator: 'gte',
weight: 0.4
},
{
metric: 'accuracy',
threshold: 0.9,
operator: 'gte',
weight: 0.3
},
{
metric: 'consistency',
threshold: 0.85,
operator: 'gte',
weight: 0.3
}
],
actions: [
{ type: 'review', action: 'manual_review' },
{ type: 'retry', action: 'agent_retry' },
{ type: 'escalate', action: 'human_escalation' }
],
required: true
};
}
}

## Selection Algorithms

### 1. Capability Matching Algorithm

    typescript

class CapabilityMatcher {
calculateCapabilityMatch(agent: AgentProfile, task: TaskAnalysis): number {
let matchScore = 0;
let totalWeight = 0;

    // Required capabilities (must match)
    const requiredMatch = this.calculateRequiredCapabilityMatch(
      agent.capabilities,
      task.capabilities.required
    );

    if (requiredMatch < 1.0) {
      return 0; // Failed requirement
    }

    // Preferred capabilities (weighted scoring)
    const preferredScore = this.calculatePreferredCapabilityScore(
      agent.capabilities,
      task.capabilities.preferred
    );
    matchScore += preferredScore * 0.4;
    totalWeight += 0.4;

    // Optional capabilities (bonus scoring)
    const optionalScore = this.calculateOptionalCapabilityScore(
      agent.capabilities,
      task.capabilities.optional
    );
    matchScore += optionalScore * 0.2;
    totalWeight += 0.2;

    // Domain expertise scoring
    const domainScore = this.calculateDomainExpertiseScore(agent, task);
    matchScore += domainScore * 0.4;
    totalWeight += 0.4;

    return matchScore / totalWeight;

}
}

### 2. Performance Scoring Algorithm

    typescript

class PerformanceScorer {
calculatePerformanceScore(agent: AgentProfile, task: TaskAnalysis): number {
const factors = {
success_rate: agent.success_rate || 0.8,
response_time: this.normalizeResponseTime(agent.avg_response_time || 30),
complexity_match: this.calculateComplexityMatch(agent.complexity_score, task.complexity.score),
reliability: agent.reliability_score || 0.85
};

    const weights = {
      success_rate: 0.4,
      response_time: 0.2,
      complexity_match: 0.25,
      reliability: 0.15
    };

    return (
      factors.success_rate * weights.success_rate +
      factors.response_time * weights.response_time +
      factors.complexity_match * weights.complexity_match +
      factors.reliability * weights.reliability
    );

}

private normalizeResponseTime(responseTime: number): number {
// Normalize to 0-1 scale (lower is better)
return Math.max(0, 1 - (responseTime / 120)); // 120 seconds as max acceptable
}
}

### 3. Resource Balancing Algorithm

    typescript

class ResourceBalancer {
async calculateAvailabilityScore(agent: AgentProfile): Promise<number> {
const concurrentTasks = agent.concurrent_tasks || 0;
const maxConcurrent = agent.max_concurrent_tasks || 5;
const lastActive = agent.last_active || new Date(0);
const timeSinceActive = Date.now() - lastActive.getTime();

    // Calculate availability based on current load
    const loadScore = Math.max(0, 1 - (concurrentTasks / maxConcurrent));

    // Calculate recency score (prefer recently active agents)
    const recencyScore = Math.min(1, timeSinceActive / (24 * 60 * 60 * 1000)); // 24 hours

    // Combine scores
    return loadScore * 0.7 + recencyScore * 0.3;

}
}

## Workflow Coordination Patterns

### 1. Sequential Pattern

    typescript

class SequentialWorkflow {
async execute(task: TaskAnalysis, agents: AgentProfile[]): Promise<WorkflowResult> {
const results = [];
let context = { task, previous_results: [] };

    for (const agent of agents) {
      const result = await this.executeAgentStep(agent, context);
      results.push(result);
      context.previous_results.push(result);

      // Quality gate validation
      if (!await this.validateStep(result, task)) {
        throw new WorkflowError(`Quality gate failed for agent: ${agent.name}`);
      }
    }

    return { results, success: true, context };

}
}

### 2. Parallel Pattern

    typescript

class ParallelWorkflow {
async execute(task: TaskAnalysis, agents: AgentProfile[]): Promise<WorkflowResult> {
const promises = agents.map(async (agent) => {
const result = await this.executeAgentStep(agent, { task });
return { agent, result };
});

    const results = await Promise.allSettled(promises);
    const successful = results.filter(r => r.status === 'fulfilled');
    const failed = results.filter(r => r.status === 'rejected');

    if (failed.length > 0) {
      await this.handleParallelFailures(failed, successful);
    }

    return {
      results: successful.map(s => s.value),
      success: failed.length === 0,
      failures: failed.length
    };

}
}

### 3. Hierarchical Pattern

    typescript

class HierarchicalWorkflow {
async execute(task: TaskAnalysis, orchestrator: AgentProfile, teams: AgentTeam[]): Promise<WorkflowResult> {
// Step 1: Orchestrator analyzes and plans
const plan = await this.createExecutionPlan(orchestrator, task, teams);

    // Step 2: Execute teams in parallel
    const teamResults = await Promise.all(
      teams.map(team => this.executeTeam(team, plan.teamAssignments[team.id]))
    );

    // Step 3: Orchestrator integrates results
    const integratedResult = await this.integrateResults(orchestrator, teamResults, task);

    return {
      result: integratedResult,
      team_results: teamResults,
      success: true
    };

}
}

## Learning and Adaptation

### 1. Performance Tracking

    typescript

class PerformanceTracker {
trackExecution(execution: WorkflowExecution): void {
const metrics = {
task_id: execution.id,
agents: execution.agents.map(a => a.name),
duration: execution.duration,
success: execution.success,
quality_score: execution.quality_score,
user_satisfaction: execution.user_satisfaction,
cost: execution.cost,
timestamp: new Date()
};

    this.storeMetrics(metrics);
    this.updateAgentProfiles(execution);
    this.identifyPatterns(metrics);

}
}

### 2. Pattern Learning

    typescript

class PatternLearner {
learnFromExecutions(): void {
const executions = this.recentExecutions(1000); // Last 1000 executions

    const patterns = this.identifySuccessPatterns(executions);
    const antiPatterns = this.identifyFailurePatterns(executions);

    this.updateSelectionCriteria(patterns, antiPatterns);
    this.optimizeCoordinationPatterns(patterns);

}
}

## Integration with Claude Code

### 1. Command Interface

    bash

# Get agent recommendations

@agent-orchestrator recommend "implement medical search functionality"

# Execute with automatic agent selection

@agent-orchestrator execute "optimize database queries" --auto-select

# View workflow plan

@agent-orchestrator plan "create HIPAA-compliant API" --detailed

# Monitor execution

@agent-orchestrator status --workflow-id=workflow_123

# Analyze performance

@agent-orchestrator analyze --agent=nextjs-pro --period=7d

### 2. Context Integration

The orchestrator integrates with Claude Code's context system:

- **Project Context**: Understanding current project state and architecture
- **Agent History**: Learning from previous agent selections and performance
- **User Preferences**: Adapting to individual user patterns and preferences
- **Resource State**: Monitoring system resources and agent availability

## Configuration

### 1. Orchestrator Configuration

    yaml

orchestrator:
version: "1.0.0"
selection:
capability_threshold: 0.7
performance_weight: 0.25
availability_weight: 0.20
cost_weight: 0.15

coordination:
max_parallel_agents: 5
timeout_per_agent: 300 # seconds
retry_attempts: 3

quality:
enable_validation: true
strict_mode: false
human_review_threshold: 0.7

learning:
enable_adaptation: true
learning_rate: 0.1
pattern_retention: 90 # days

monitoring:
enable_metrics: true
alert_thresholds:
failure_rate: 0.15
response_time: 120
cost_overrun: 1.2

## Usage Examples

### 1. Simple Task Selection

    bash

@agent-orchestrator execute "implement user authentication"

# Selects: @backend-architect + @security-auditor + @jwt-expert

### 2. Complex Multi-Agent Workflow

    bash

@agent-orchestrator execute "build medical content management system"

# Selects: @task-orchestrator â†’ [@healthcare-compliance-agent, @nextjs-pro, @backend-architect, @elasticsearch-expert]

### 3. Performance Optimization

    bash

@agent-orchestrator execute "optimize application performance"

# Selects: @performance-engineer + @database-optimizer + @nextjs-pro

## Best Practices

### 1. When to Use the Orchestrator

**Use for**:

- Complex tasks requiring multiple agents
- Performance-critical applications
- Cost optimization scenarios
- Quality assurance requirements
- Learning and adaptation needs

### 2. When to Use Direct Selection

**Use for**:

- Simple, well-defined tasks
- Agent-specific expertise requirements
- Rapid prototyping
- Debugging specific agent behavior
- Learning agent capabilities

### 3. Optimization Tips

1. **Provide Clear Context**: Include project state and requirements
2. **Set Quality Expectations**: Define quality requirements upfront
3. **Monitor Performance**: Track execution metrics and adjust accordingly
4. **Leverage Learning**: Allow the system to learn from your patterns
5. **Provide Feedback**: Help the system improve with success/failure indicators

---

This Agent Orchestrator represents a sophisticated approach to intelligent agent selection and workflow coordination, enabling optimal utilization of the AI agent ecosystem while ensuring quality, performance, and cost efficiency in enterprise-grade AI-powered software development.
